# Backend Migration Guide

This guide shows how to migrate between different messaging backends (NATS, AWS, Google Cloud, Azure) with zero code changes to your services.

## Overview

The modular messaging architecture allows you to switch between different messaging backends by simply changing configuration. Your service code remains exactly the same.

## Supported Backends

### NATS (Default)
- **Use Case**: Development, on-premises, high-performance messaging
- **Pros**: Fast, lightweight, easy to deploy
- **Cons**: Requires infrastructure management

### AWS SNS/SQS/EventBridge
- **Use Case**: AWS cloud deployments, enterprise scale
- **Pros**: Fully managed, scales automatically, integrates with AWS services
- **Cons**: AWS vendor lock-in, potentially higher costs

### Google Cloud Pub/Sub (Coming Soon)
- **Use Case**: Google Cloud deployments
- **Pros**: Fully managed, global scale
- **Cons**: Google Cloud vendor lock-in

### Azure Service Bus (Coming Soon)
- **Use Case**: Azure deployments
- **Pros**: Fully managed, enterprise features
- **Cons**: Azure vendor lock-in

## Configuration Examples

### NATS Configuration

```python\nfrom messaging import MessagingConfig\nfrom modular_service import ModularServiceConfig\n\n# Simple NATS setup\nconfig = ModularServiceConfig(\n    name=\"my_service\",\n    messaging=MessagingConfig.nats(\n        url=\"nats://localhost:4222\"\n    )\n)\n\n# NATS cluster setup\nconfig = ModularServiceConfig(\n    name=\"my_service\",\n    messaging=MessagingConfig.nats(\n        url=\"nats://nats1:4222,nats2:4222,nats3:4222\",\n        user=\"service_user\",\n        password=\"service_password\"\n    )\n)\n```\n\n### AWS Configuration\n\n```python\n# AWS with environment credentials\nconfig = ModularServiceConfig(\n    name=\"my_service\",\n    messaging=MessagingConfig.aws_sns_sqs(\n        region=\"us-east-1\"\n        # Uses AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY from environment\n    )\n)\n\n# AWS with explicit credentials\nconfig = ModularServiceConfig(\n    name=\"my_service\",\n    messaging=MessagingConfig.aws_sns_sqs(\n        region=\"us-west-2\",\n        access_key_id=\"AKIA...\",\n        secret_access_key=\"xyz...\"\n    )\n)\n\n# AWS with IAM role (recommended for EC2/ECS)\nconfig = ModularServiceConfig(\n    name=\"my_service\",\n    messaging=MessagingConfig.aws_sns_sqs(\n        region=\"eu-west-1\"\n        # Uses IAM role attached to EC2 instance or ECS task\n    )\n)\n```\n\n### Environment-Based Configuration\n\n```python\nimport os\nfrom messaging import MessagingConfig\n\ndef create_messaging_config() -> MessagingConfig:\n    \"\"\"Create messaging config based on environment\"\"\"\n    backend = os.getenv(\"MESSAGING_BACKEND\", \"nats\")\n    \n    if backend == \"nats\":\n        return MessagingConfig.nats(\n            url=os.getenv(\"NATS_URL\", \"nats://localhost:4222\")\n        )\n    \n    elif backend == \"aws\":\n        return MessagingConfig.aws_sns_sqs(\n            region=os.getenv(\"AWS_REGION\", \"us-east-1\")\n        )\n    \n    else:\n        raise ValueError(f\"Unknown messaging backend: {backend}\")\n\n# Usage\nconfig = ModularServiceConfig(\n    name=\"my_service\",\n    messaging=create_messaging_config()\n)\n```\n\n## Migration Strategies\n\n### 1. Development to Production Migration\n\n**Scenario**: Develop with NATS locally, deploy to AWS in production\n\n```bash\n# Development (.env.development)\nMESSAGING_BACKEND=nats\nNATS_URL=nats://localhost:4222\n\n# Production (.env.production)\nMESSAGING_BACKEND=aws\nAWS_REGION=us-east-1\n# AWS credentials via IAM role\n```\n\n### 2. Blue-Green Deployment\n\n**Scenario**: Migrate from NATS to AWS with zero downtime\n\n```python\nclass MigrationService(ModularService):\n    \"\"\"Service that can run on multiple backends simultaneously\"\"\"\n    \n    def __init__(self, primary_config: ModularServiceConfig, secondary_config: ModularServiceConfig = None):\n        super().__init__(primary_config)\n        \n        # Optional secondary messaging for migration\n        self.secondary_client = None\n        if secondary_config:\n            self.secondary_client = MessagingFactory.create_client(\n                secondary_config.messaging.backend,\n                **secondary_config.messaging.connection_params\n            )\n    \n    async def start(self):\n        await super().start()\n        \n        if self.secondary_client:\n            await self.secondary_client.connect()\n            self.logger.info(\"Connected to secondary messaging backend\")\n    \n    async def publish_event(self, subject: str, **kwargs):\n        # Publish to both backends during migration\n        await super().publish_event(subject, **kwargs)\n        \n        if self.secondary_client:\n            data = json.dumps(kwargs).encode()\n            await self.secondary_client.publish(subject, data)\n```\n\n### 3. Gradual Migration\n\n**Scenario**: Migrate services one by one\n\n```yaml\n# docker-compose.yml for gradual migration\nversion: '3.8'\nservices:\n  # Legacy services on NATS\n  legacy-service:\n    environment:\n      - MESSAGING_BACKEND=nats\n      - NATS_URL=nats://nats:4222\n  \n  # New services on AWS\n  new-service:\n    environment:\n      - MESSAGING_BACKEND=aws\n      - AWS_REGION=us-east-1\n  \n  # Bridge service that connects both\n  bridge-service:\n    environment:\n      - PRIMARY_BACKEND=nats\n      - SECONDARY_BACKEND=aws\n```\n\n## Service Code (Backend Agnostic)\n\nYour service code remains identical across all backends:\n\n```python\nfrom modular_service import ModularService, rpc, event_handler\n\nclass UserService(ModularService):\n    \"\"\"This code works with ANY messaging backend\"\"\"\n    \n    @rpc\n    async def create_user(self, username: str, email: str) -> dict:\n        user = {\n            \"id\": f\"user_{len(self.users)}\",\n            \"username\": username,\n            \"email\": email\n        }\n        \n        # This publish_event works with NATS, AWS, Google Cloud, etc.\n        await self.publish_event(\n            \"users.created\",\n            user_id=user[\"id\"],\n            username=username\n        )\n        \n        return user\n    \n    @event_handler(\"orders.created\")\n    async def on_order_created(self, subject: str, user_id: str, **kwargs):\n        # This event handler works with any backend\n        self.logger.info(f\"User {user_id} created an order\")\n```\n\n## Backend-Specific Considerations\n\n### NATS Specifics\n\n```python\n# NATS supports wildcard subscriptions natively\n@event_handler(\"orders.*\")  # Works perfectly\n@event_handler(\"users.>\")   # Works perfectly\n\n# JetStream for persistence\nconfig = MessagingConfig.nats(\n    url=\"nats://localhost:4222\",\n    jetstream=True  # Enable JetStream for durable messaging\n)\n```\n\n### AWS Specifics\n\n```python\n# AWS maps subjects to SNS topics and SQS queues\n# Wildcards are handled via EventBridge rules\n\n# This creates SNS topic: cliffracer-users-created\nsubject = \"users.created\"\n\n# This creates EventBridge rule matching pattern\n@event_handler(\"orders.*\")  # Handled via EventBridge\n\n# Configure AWS-specific settings\nconfig = MessagingConfig.aws_sns_sqs(\n    region=\"us-east-1\",\n    prefix=\"myapp\",  # Topic/queue prefix: myapp-users-created\n    dead_letter_enabled=True,\n    max_retries=3\n)\n```\n\n## Performance Characteristics\n\n### NATS Performance\n- **Latency**: <1ms for local deployments\n- **Throughput**: 1M+ messages/second\n- **Ordering**: Per-subject ordering\n- **Durability**: JetStream provides durability\n\n### AWS Performance\n- **Latency**: 10-100ms (network dependent)\n- **Throughput**: 100K+ messages/second per topic\n- **Ordering**: FIFO queues for ordering (additional cost)\n- **Durability**: Built-in with SQS/SNS\n\n## Cost Considerations\n\n### NATS Costs\n- **Infrastructure**: Server hosting costs\n- **Management**: Operational overhead\n- **Scaling**: Manual cluster management\n\n### AWS Costs\n- **SNS**: $0.50 per million requests\n- **SQS**: $0.40 per million requests\n- **EventBridge**: $1.00 per million events\n- **No operational overhead**\n\n## Migration Checklist\n\n### Pre-Migration\n\n- [ ] Identify all services and their messaging patterns\n- [ ] Set up new messaging backend (AWS/Google/Azure accounts)\n- [ ] Configure credentials and permissions\n- [ ] Test new backend with sample services\n- [ ] Plan rollback strategy\n\n### Migration Process\n\n- [ ] Update service configurations\n- [ ] Deploy services with dual messaging (if needed)\n- [ ] Verify all services can communicate\n- [ ] Monitor for errors and performance issues\n- [ ] Switch traffic to new backend\n- [ ] Disable old backend\n\n### Post-Migration\n\n- [ ] Monitor service health and performance\n- [ ] Verify all events are being processed\n- [ ] Check cost and billing\n- [ ] Update documentation\n- [ ] Clean up old infrastructure\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Authentication Failures**\n   ```bash\n   # Check AWS credentials\n   aws sts get-caller-identity\n   \n   # Check NATS connectivity\n   nats server check\n   ```\n\n2. **Message Delivery Issues**\n   ```python\n   # Check service stats\n   stats = await service.get_stats()\n   print(stats['messaging'])\n   ```\n\n3. **Performance Problems**\n   ```python\n   # Enable debug logging\n   import logging\n   logging.getLogger('messaging').setLevel(logging.DEBUG)\n   ```\n\n### Backend-Specific Debugging\n\n**NATS**:\n```bash\n# Check NATS server stats\ncurl http://localhost:8222/varz\n\n# Monitor connections\ncurl http://localhost:8222/connz\n```\n\n**AWS**:\n```bash\n# Check SNS topics\naws sns list-topics\n\n# Check SQS queues\naws sqs list-queues\n\n# Monitor CloudWatch metrics\naws cloudwatch get-metric-statistics --namespace AWS/SNS\n```\n\n## Best Practices\n\n1. **Use Environment Variables**: Never hardcode backend configurations\n2. **Test All Backends**: Ensure your services work with all target backends\n3. **Monitor Costs**: Set up billing alerts for cloud backends\n4. **Plan for Failures**: Implement proper error handling and retries\n5. **Document Dependencies**: Keep track of which services use which backends\n6. **Use Infrastructure as Code**: Manage backend resources with Terraform/CloudFormation\n\n## Example: Complete Migration\n\n```python\n#!/usr/bin/env python3\n\"\"\"Migration script to switch backends\"\"\"\n\nimport os\nimport asyncio\nfrom typing import List\nfrom modular_service import ModularService, ModularServiceConfig\nfrom messaging import MessagingConfig\n\nasync def migrate_services(services: List[str], from_backend: str, to_backend: str):\n    \"\"\"Migrate services from one backend to another\"\"\"\n    \n    print(f\"Migrating {len(services)} services from {from_backend} to {to_backend}\")\n    \n    # Create configurations\n    old_config = create_config(from_backend)\n    new_config = create_config(to_backend)\n    \n    for service_name in services:\n        print(f\"\\nMigrating {service_name}...\")\n        \n        try:\n            # Test connectivity to new backend\n            test_service = ModularService(\n                ModularServiceConfig(name=f\"test_{service_name}\", messaging=new_config)\n            )\n            \n            await test_service.start()\n            await test_service.stop()\n            \n            print(f\"âœ… {service_name} migration test successful\")\n            \n        except Exception as e:\n            print(f\"âŒ {service_name} migration test failed: {e}\")\n            return False\n    \n    print(\"\\nðŸš€ All services ready for migration!\")\n    print(f\"Update MESSAGING_BACKEND environment variable to '{to_backend}'\")\n    print(\"Restart your services to complete the migration.\")\n    \n    return True\n\ndef create_config(backend: str) -> MessagingConfig:\n    if backend == \"nats\":\n        return MessagingConfig.nats()\n    elif backend == \"aws\":\n        return MessagingConfig.aws_sns_sqs()\n    else:\n        raise ValueError(f\"Unknown backend: {backend}\")\n\nif __name__ == \"__main__\":\n    services = [\"user_service\", \"notification_service\", \"order_service\"]\n    asyncio.run(migrate_services(services, \"nats\", \"aws\"))\n```\n\nThis modular architecture gives you the flexibility to choose the best messaging backend for each environment while keeping your service code clean and portable.\n"